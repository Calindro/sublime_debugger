# from https://github.com/sublimelsp/LSP/tree/st4000-exploration/stubs
# with the following license

# MIT License

# Copyright (c) 2017 - 2020 Tom van Ommeren

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Stubs for sublime (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Callable, Dict, Iterator, List, Optional, Reversible, Sequence, Tuple, Union


class _LogWriter:
    def flush(self) -> None:
        ...

    def write(self, s: str) -> None:
        ...


HOVER_TEXT: int = ...
HOVER_GUTTER: int = ...
HOVER_MARGIN: int = ...
ENCODED_POSITION: int = ...
TRANSIENT: int = ...
SEMI_TRANSIENT: int = ...
FORCE_GROUP: int = ...
ADD_TO_SELECTION: int = ...
IGNORECASE: int = ...
LITERAL: int = ...
MONOSPACE_FONT: int = ...
KEEP_OPEN_ON_FOCUS_LOST: int = ...
HTML: int = ...
COOPERATE_WITH_AUTO_COMPLETE: int = ...
HIDE_ON_MOUSE_MOVE: int = ...
HIDE_ON_MOUSE_MOVE_AWAY: int = ...
KEEP_ON_SELECTION_MODIFIED: int = ...
DRAW_EMPTY: int = ...
HIDE_ON_MINIMAP: int = ...
DRAW_EMPTY_AS_OVERWRITE: int = ...
PERSISTENT: int = ...
DRAW_OUTLINED: int = ...
DRAW_NO_FILL: int = ...
DRAW_NO_OUTLINE: int = ...
DRAW_SOLID_UNDERLINE: int = ...
DRAW_STIPPLED_UNDERLINE: int = ...
DRAW_SQUIGGLY_UNDERLINE: int = ...
HIDDEN: int = ...
OP_EQUAL: int = ...
OP_NOT_EQUAL: int = ...
OP_REGEX_MATCH: int = ...
OP_NOT_REGEX_MATCH: int = ...
OP_REGEX_CONTAINS: int = ...
OP_NOT_REGEX_CONTAINS: int = ...
CLASS_WORD_START: int = ...
CLASS_WORD_END: int = ...
CLASS_PUNCTUATION_START: int = ...
CLASS_PUNCTUATION_END: int = ...
CLASS_SUB_WORD_START: int = ...
CLASS_SUB_WORD_END: int = ...
CLASS_LINE_START: int = ...
CLASS_LINE_END: int = ...
CLASS_EMPTY_LINE: int = ...
INHIBIT_WORD_COMPLETIONS: int = ...
INHIBIT_EXPLICIT_COMPLETIONS: int = ...
INHIBIT_REORDER: int = ...
DYNAMIC_COMPLETIONS: int = ...
COMPLETION_FLAG_KEEP_PREFIX: int = ...
DIALOG_CANCEL: int = ...
DIALOG_YES: int = ...
DIALOG_NO: int = ...
UI_ELEMENT_SIDE_BAR: int = ...
UI_ELEMENT_MINIMAP: int = ...
UI_ELEMENT_TABS: int = ...
UI_ELEMENT_STATUS_BAR: int = ...
UI_ELEMENT_MENU: int = ...
UI_ELEMENT_OPEN_FILES: int = ...
LAYOUT_INLINE: int = ...
LAYOUT_BELOW: int = ...
LAYOUT_BLOCK: int = ...
KIND_ID_AMBIGUOUS: int = ...
KIND_ID_KEYWORD: int = ...
KIND_ID_TYPE: int = ...
KIND_ID_FUNCTION: int = ...
KIND_ID_NAMESPACE: int = ...
KIND_ID_NAVIGATION: int = ...
KIND_ID_MARKUP: int = ...
KIND_ID_VARIABLE: int = ...
KIND_ID_SNIPPET: int = ...
KIND_AMBIGUOUS: Tuple[int, str, str] = ...
KIND_KEYWORD: Tuple[int, str, str] = ...
KIND_TYPE: Tuple[int, str, str] = ...
KIND_FUNCTION: Tuple[int, str, str] = ...
KIND_NAMESPACE: Tuple[int, str, str] = ...
KIND_NAVIGATION: Tuple[int, str, str] = ...
KIND_MARKUP: Tuple[int, str, str] = ...
KIND_VARIABLE: Tuple[int, str, str] = ...
KIND_SNIPPET: Tuple[int, str, str] = ...
COMPLETION_FORMAT_TEXT: int = ...
COMPLETION_FORMAT_SNIPPET: int = ...


class Settings:
    settings_id: int = ...

    def __init__(self, id: int) -> None:
        ...

    def get(self, key: str, default: Optional[Any] = ...) -> Optional[Any]:
        ...

    def has(self, key: str) -> bool:
        ...

    def set(self, key: str, value: Any) -> None:
        ...

    def erase(self, key: str) -> None:
        ...

    def add_on_change(self, tag: str, callback: Callable[[], None]) -> None:
        ...

    def clear_on_change(self, tag: str) -> None:
        ...


def version() -> str:
    ...


def platform() -> str:
    ...


def arch() -> str:
    ...


def channel() -> str:
    ...


def executable_path() -> str:
    ...


def executable_hash() -> str:
    ...


def packages_path() -> str:
    ...


def installed_packages_path() -> str:
    ...


def cache_path() -> str:
    ...


def status_message(msg: str) -> None:
    ...


def error_message(msg: str) -> None:
    ...


def message_dialog(msg: str) -> None:
    ...


def ok_cancel_dialog(msg: str, ok_title: str = ...) -> bool:
    ...


def yes_no_cancel_dialog(msg: str, yes_title: str = ..., no_title: str = ...) -> int:
    ...


def run_command(cmd: str, args: Optional[Any] = ...) -> None:
    ...


def get_clipboard(size_limit: int = ...) -> str:
    ...


def set_clipboard(text: str) -> None:
    ...


def log_commands(flag: bool) -> None:
    ...


def log_input(flag: bool) -> None:
    ...


def log_result_regex(flag: bool) -> None:
    ...


def log_indexing(flag: bool) -> None:
    ...


def log_build_systems(flag: bool) -> None:
    ...


def score_selector(scope_name: str, selector: str) -> int:
    ...


def load_resource(name: str) -> str:
    ...


def load_binary_resource(name: str) -> bytes:
    ...


def find_resources(pattern: str) -> Sequence[str]:
    ...


def encode_value(val: Any, pretty: bool = ...) -> str:
    ...


def decode_value(data: str) -> Any:
    ...


def expand_variables(val: Any, variables: dict[Any, Any]) -> Any:
    ...


def load_settings(base_name: str) -> Settings:
    ...


def save_settings(base_name: str) -> None:
    ...


def set_timeout(f: Callable[[], Any], timeout_ms: int = ...) -> None:
    ...


def set_timeout_async(f: Callable[[], Any], timeout_ms: int = ...) -> None:
    ...


def active_window() -> 'Window':
    ...


def windows() -> 'Sequence[Window]':
    ...


def get_macro() -> Sequence[dict[Any, Any]]:
    ...


def syntax_from_path(syntax_path: str) -> Optional[Syntax]:
    ...


def command_url(cmd: str, args: Optional[dict[Any, Any]] = ...) -> str:
    ...


class Syntax:
    path: str = ...
    name: str = ...
    hidden: bool = ...
    scope: str = ...

    def __init__(self, path: str, name: str, hidden: bool, scope: str) -> None:
        ...


class CompletionItem:
    flags: int = ...

    def __init__(
            self,
            trigger: str,
            annotation: str = "",
            completion: str = "",
            completion_format: int = COMPLETION_FORMAT_TEXT,
            kind: Tuple[int, str, str] = KIND_AMBIGUOUS,
            details: str = "") -> None:
        ...

    @classmethod
    def snippet_completion(
            cls,
            trigger: str,
            snippet: str,
            annotation: str = " ",
            kind: Tuple[int, str, str] = KIND_SNIPPET,
            details: str = "") -> 'CompletionItem':
        ...

    @classmethod
    def command_completion(cls,
                           trigger: str,
                           command: str,
                           args: dict[Any, Any] = {},
                           annotation: str = "",
                           kind: Tuple[int, str, str] = KIND_AMBIGUOUS,
                           details: str = ""
                           ) -> 'CompletionItem':
        ...


class CompletionList:
    def set_completions(self, completions: List[CompletionItem], flags: int = 0) -> None:
        ...


class Window:
    window_id: int = ...
    settings_object: Settings = ...
    template_settings_object: Any = ...

    def __init__(self, id: int) -> None:
        ...

    def __eq__(self, other: object) -> bool:
        ...

    def __bool__(self) -> bool:
        ...

    def id(self) -> int:
        ...

    def is_valid(self) -> bool:
        ...

    # def hwnd(self): ...
    def active_sheet(self) -> 'Sheet':
        ...

    def active_view(self) -> 'Optional[View]':
        ...

    def run_command(self, cmd: str, args: Optional[Any] = ...) -> None:
        ...

    def new_file(self, flags: int = ..., syntax: str = ...) -> 'View':
        ...

    def open_file(self, fname: str, flags: int = ..., group: int = ...) -> 'View':
        ...

    def find_open_file(self, fname: str) -> 'Optional[View]':
        ...

    def num_groups(self) -> int:
        ...

    def active_group(self) -> int:
        ...

    def focus_group(self, idx: int) -> None:
        ...

    def focus_sheet(self, sheet: 'Sheet') -> None:
        ...

    def focus_view(self, view: 'View') -> None:
        ...

    def get_sheet_index(self, sheet: 'Sheet') -> Tuple[int, int]:
        ...

    def get_view_index(self, view: 'View') -> Tuple[int, int]:
        ...

    def set_sheet_index(self, sheet: 'Sheet', group: int, idx: int) -> None:
        ...

    def set_view_index(self, view: 'View', group: int, idx: int) -> None:
        ...

    def sheets(self) -> 'List[Sheet]':
        ...

    def views(self) -> 'List[View]':
        ...

    def active_sheet_in_group(self, group: int) -> 'Sheet':
        ...

    def active_view_in_group(self, group: int) -> 'View':
        ...

    def sheets_in_group(self, group: int) -> 'List[Sheet]':
        ...

    def views_in_group(self, group: int) -> 'List[View]':
        ...

    def transient_sheet_in_group(self, group: int) -> 'Sheet':
        ...

    def transient_view_in_group(self, group: int) -> 'View':
        ...

    # def layout(self): ...
    # def get_layout(self): ...
    # def set_layout(self, layout): ...
    def create_output_panel(self, name: str, unlisted: bool = ...) -> 'View':
        ...

    def find_output_panel(self, name: str) -> 'Optional[View]':
        ...

    def destroy_output_panel(self, name: str) -> None:
        ...

    def active_panel(self) -> Optional[str]:
        ...

    def panels(self) -> List[str]:
        ...

    def get_output_panel(self, name: str) -> 'Optional[View]':
        ...

    def show_input_panel(self, caption: str, initial_text: str, on_done: Optional[Callable],
                         on_change: Optional[Callable], on_cancel: Optional[Callable]) -> 'View':
        ...

    def show_quick_panel(self,
                         items: List[Any],
                         on_select: Callable,
                         flags: int = ...,
                         selected_index: int = ...,
                         on_highlight: Optional[Callable] = ...,
                         placeholder: Optional[str] = ...) -> None:
        ...

    def is_sidebar_visible(self) -> bool:
        ...

    def set_sidebar_visible(self, flag: bool) -> None:
        ...

    def is_minimap_visible(self) -> bool:
        ...

    def set_minimap_visible(self, flag: bool) -> None:
        ...

    def is_status_bar_visible(self) -> bool:
        ...

    def set_status_bar_visible(self, flag: bool) -> None:
        ...

    def get_tabs_visible(self) -> bool:
        ...

    def set_tabs_visible(self, flag: bool) -> None:
        ...

    def is_menu_visible(self) -> bool:
        ...

    def set_menu_visible(self, flag: bool) -> None:
        ...

    def folders(self) -> List[str]:
        ...

    def project_file_name(self) -> str:
        ...

    def project_data(self) -> Optional[dict[Any, Any]]:
        ...

    def set_project_data(self, v: dict[Any, Any]) -> None:
        ...

    def settings(self) -> Settings:
        ...

    # def template_settings(self): ...
    def lookup_symbol_in_index(self, sym: str) -> List[str]:
        ...

    def lookup_symbol_in_open_files(self, sym: str) -> List[str]:
        ...

    def extract_variables(self) -> dict[Any, Any]:
        ...

    def status_message(self, msg: str) -> None:
        ...


class Edit:
    edit_token: Any = ...

    def __init__(self, token: Any) -> None:
        ...


class Region:
    a: int = ...
    b: int = ...
    xpos: int = ...

    def __init__(self, a: int, b: Optional[int] = ..., xpos: int = ...) -> None:
        ...

    def __len__(self) -> int:
        ...

    def __eq__(self, rhs: object) -> bool:
        ...

    def __lt__(self, rhs: object) -> bool:
        ...

    def empty(self) -> bool:
        ...

    def begin(self) -> int:
        ...

    def end(self) -> int:
        ...

    def size(self) -> int:
        ...

    def contains(self, x: 'Union[Region, int]') -> bool:
        ...

    def cover(self, rhs: 'Region') -> 'Region':
        ...

    def intersection(self, rhs: 'Region') -> 'Region':
        ...

    def intersects(self, rhs: 'Region') -> bool:
        ...

    def to_tuple(self) -> Tuple[int, int]:
        ...


class Selection(Reversible):
    view_id: Any = ...

    def __init__(self, id: Any) -> None:
        ...

    def __reversed__(self) -> Iterator[Region]:
        ...

    def __iter__(self) -> Iterator[Region]:
        ...

    def __len__(self) -> int:
        ...

    def __getitem__(self, index: int) -> Region:
        ...

    def __delitem__(self, index: int) -> None:
        ...

    def __eq__(self, rhs: Any) -> bool:
        ...

    def __lt__(self, rhs: Any) -> bool:
        ...

    def __bool__(self) -> bool:
        ...

    def is_valid(self) -> bool:
        ...

    def clear(self) -> None:
        ...

    def add(self, x: Union[Region, int]) -> None:
        ...

    def add_all(self, regions: Iterator[Union[Region, int]]) -> None:
        ...

    def subtract(self, region: Region) -> None:
        ...

    def contains(self, region: Region) -> bool:
        ...


class Sheet:
    sheet_id: Any = ...

    def __init__(self, id: Any) -> None:
        ...

    def __eq__(self, other: object) -> bool:
        ...

    def id(self) -> int:
        ...

    def window(self) -> Optional[Window]:
        ...

    def view(self) -> 'Optional[View]':
        ...

    def is_transient(self) -> bool:
        ...


class HtmlSheet:
    sheet_id: Any = ...

    def __init__(self, id: Any) -> None:
        ...

    def set_name(self, name: str) -> None:
        ...

    def set_contents(self, contents: str) -> None:
        ...


class View:
    view_id: Any = ...
    selection: Any = ...
    settings_object: Any = ...

    def __init__(self, id: Any) -> None:
        ...

    def __len__(self) -> int:
        ...

    def __eq__(self, other: object) -> bool:
        ...

    def __bool__(self) -> bool:
        ...

    def sheet(self) -> Sheet:
        ...

    def syntax(self) -> Any:
        ...

    def element(self) -> Optional[str]:
        ...

    def id(self) -> int:
        ...

    def buffer(self) -> "Optional[Buffer]":
        ...

    def buffer_id(self) -> int:
        ...

    def is_valid(self) -> bool:
        ...

    def is_primary(self) -> bool:
        ...

    def window(self) -> Optional[Window]:
        ...

    def file_name(self) -> Optional[str]:
        ...

    def close(self) -> None:
        ...

    def retarget(self, new_fname: str) -> None:
        ...

    def name(self) -> str:
        ...

    def set_name(self, name: str) -> None:
        ...

    def is_loading(self) -> bool:
        ...

    def is_dirty(self) -> bool:
        ...

    def is_read_only(self) -> bool:
        ...

    def set_read_only(self, read_only: bool) -> None:
        ...

    def is_scratch(self) -> bool:
        ...

    def set_scratch(self, scratch: bool) -> None:
        ...

    def encoding(self) -> str:
        ...

    def set_encoding(self, encoding_name: str) -> None:
        ...

    def line_endings(self) -> str:
        ...

    def set_line_endings(self, line_ending_name: str) -> None:
        ...

    def size(self) -> int:
        ...

    # def begin_edit(self, edit_token, cmd, args: Optional[Any] = ...) -> Edit: ...
    # def end_edit(self, edit: Edit) -> None: ...
    def is_in_edit(self) -> bool:
        ...

    def insert(self, edit: Edit, pt: int, text: str) -> None:
        ...

    def erase(self, edit: Edit, r: Region) -> None:
        ...

    def replace(self, edit: Edit, r: Region, text: str) -> None:
        ...

    def change_count(self) -> int:
        ...

    def run_command(self, cmd: str, args: Optional[Any] = ...) -> None:
        ...

    def sel(self) -> Selection:
        ...

    def substr(self, x: Union[Region, int]) -> str:
        ...

    def find(self, pattern: str, start_pt: int, flags: int = ...) -> Optional[Region]:
        ...

    def find_all(self, pattern: str, flags: int = ..., fmt: Optional[Any] = ...,
                 extractions: Optional[Any] = ...) -> 'List[Region]':
        ...

    def settings(self) -> Settings:
        ...

    # def meta_info(self, key, pt: int): ...
    def extract_scope(self, pt: int) -> Region:
        ...

    def scope_name(self, pt: int) -> str:
        ...

    def match_selector(self, pt: int, selector: str) -> bool:
        ...

    def score_selector(self, pt: int, selector: str) -> int:
        ...

    def find_by_selector(self, selector: str) -> List[Region]:
        ...

    # def indented_region(self, pt: int): ...
    # def indentation_level(self, pt: int): ...
    def has_non_empty_selection_region(self) -> bool:
        ...

    def lines(self, r: Region) -> List[Region]:
        ...

    def split_by_newlines(self, r: Region) -> List[Region]:
        ...

    def line(self, x: Union[Region, int]) -> Region:
        ...

    def full_line(self, x: Union[Region, int]) -> Region:
        ...

    def word(self, x: Union[Region, int]) -> Region:
        ...

    def classify(self, pt: int) -> int:
        ...

    def find_by_class(self, pt: int, forward: bool, classes: int, separators: str = ...) -> int:
        ...

    def expand_by_class(self, x: Union[Region, int], classes: int, separators: str = ...) -> Region:
        ...

    def rowcol(self, tp: int) -> Tuple[int, int]:
        ...

    def rowcol_utf8(self, tp: int) -> Tuple[int, int]:
        ...

    def rowcol_utf16(self, tp: int) -> Tuple[int, int]:
        ...

    def text_point(self, row: int, col: int, *, clamp_column: bool = False) -> int:
        ...

    def text_point_utf8(self, row: int, col_utf8: int, *, clamp_column: bool = False) -> int:
        ...

    def text_point_utf16(self, row: int, col_utf16: int, *, clamp_column: bool = False) -> int:
        ...

    def visible_region(self) -> Region:
        ...

    def show(self, x: Union[Selection, Region, int], show_surrounds: bool = ...) -> None:
        ...

    def show_at_center(self, x: Union[Selection, Region, int]) -> None:
        ...

    def viewport_position(self) -> Tuple[int, int]:
        ...

    def set_viewport_position(self, xy: Tuple[int, int], animate: bool = ...) -> None:
        ...

    def viewport_extent(self) -> Tuple[int, int]:
        ...

    def layout_extent(self) -> Tuple[int, int]:
        ...

    def text_to_layout(self, tp: int) -> Tuple[int, int]:
        ...

    def layout_to_text(self, xy: Tuple[int, int]) -> int:
        ...

    def window_to_layout(self, xy: Tuple[int, int]) -> Tuple[int, int]:
        ...

    def window_to_text(self, xy: Tuple[int, int]) -> int:
        ...

    def line_height(self) -> float:
        ...

    def em_width(self) -> float:
        ...

    # def is_folded(self, sr) -> bool: ...
    # def folded_regions(self): ...
    def fold(self, x: Union[Region, List[Region]]) -> bool:
        ...

    def unfold(self, x: Union[Region, List[Region]]) -> List[Region]:
        ...

    def add_regions(self, key: str, regions: List[Region], scope: str = ..., icon: str = ..., flags: int = ...,
                    annotations: List[str] = ..., annotation_color: str = ...,
                    on_navigate: Callable[[str], None] = ..., on_close: Callable[[], None] = ...) -> None:
        ...

    def get_regions(self, key: str) -> List[Region]:
        ...

    def erase_regions(self, key: str) -> None:
        ...

    # def add_phantom(self, key: str, region: Region, content: str, layout, on_navigate: Optional[Any] = ...): ...
    # def erase_phantoms(self, key: str) -> None: ...
    # def erase_phantom_by_id(self, pid) -> None: ...
    # def query_phantom(self, pid): ...
    # def query_phantoms(self, pids): ...
    def assign_syntax(self, syntax_file: str) -> None:
        ...

    def set_syntax_file(self, syntax_file: str) -> None:
        ...

    def symbols(self) -> List[Tuple[Region, str]]:
        ...

    # def get_symbols(self): ...
    # def indexed_symbols(self): ...
    def set_status(self, key: str, value: str) -> None:
        ...

    def get_status(self, key: str) -> str:
        ...

    def erase_status(self, key: str) -> None:
        ...

    # def extract_completions(self, prefix: str, tp: int = ...): ...
    # def find_all_results(self): ...
    # def find_all_results_with_text(self): ...
    def command_history(self, delta: int, modifying_only: bool = ...) -> 'Tuple[str, dict[Any, Any], int]':
        ...

    def overwrite_status(self) -> bool:
        ...

    def set_overwrite_status(self, value: bool) -> None:
        ...

    def show_popup_menu(self, items: List[str], on_select: 'Callable', flags: int = ...) -> None:
        ...

    def show_popup(self,
                   content: str,
                   flags: int = ...,
                   location: int = ...,
                   max_width: int = ...,
                   max_height: int = ...,
                   on_navigate: Optional[Any] = ...,
                   on_hide: Optional[Any] = ...) -> None:
        ...

    def update_popup(self, content: str) -> None:
        ...

    def is_popup_visible(self) -> bool:
        ...

    def hide_popup(self) -> None:
        ...

    def is_auto_complete_visible(self) -> bool:
        ...

    def change_id(self) -> Any:  # opaque handle object
        ...

    def transform_region_from(self, region: Region, change_id: Any) -> Region:
        ...

    def style_for_scope(self, scope: str) -> Dict[str, str]:
        ...


class Buffer:
    buffer_id: int = ...

    def __init__(self, id: int) -> None:
        ...

    def views(self) -> Optional[List[View]]:
        ...

    def primary_view(self) -> Optional[View]:
        ...


class Phantom:
    region: Region = ...
    content: Any = ...
    layout: Any = ...
    on_navigate: Any = ...
    id: Any = ...

    def __init__(self, region: Region, content: str, layout: int, on_navigate: Optional[Any] = ...) -> None:
        ...

    def __eq__(self, rhs: object) -> bool:
        ...


class PhantomSet:
    view: View = ...
    key: Any = ...
    phantoms: Any = ...

    def __init__(self, view: View, key: str = ...) -> None:
        ...

    def __del__(self) -> None:
        ...

    def update(self, new_phantoms: Sequence[Phantom]) -> None:
        ...


class HistoricPosition:
    pt: int = ...
    row: int = ...
    col: int = ...
    col_utf16: int = ...
    col_utf8: int = ...


class TextChange:
    a: HistoricPosition = ...
    b: HistoricPosition = ...
    str: str = ...
    len_utf8: int = ...
    len_utf16: int = ...


class QuickPanelItem:
    def __init__(
        self,
        trigger: str,
        details: Union[str, List[str]] = "",
        annotation: str = "",
        kind: Tuple[int, str, str] = KIND_AMBIGUOUS
    ) -> None:
        ...